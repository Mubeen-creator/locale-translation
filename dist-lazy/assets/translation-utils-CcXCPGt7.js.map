{"version":3,"file":"translation-utils-CcXCPGt7.js","sources":["../../src/utils/translationUtils.js"],"sourcesContent":["// Translation utilities for dynamic content translation\nimport { ref, onMounted } from 'vue'\nimport { enterpriseI18n } from '@/i18n/enterprise/i18n'\n\n// Cache for translations to avoid repeated requests\nconst translationCache = new Map()\n\n// Logger utility\nconst logger = {\n  debug: (message, ...args) => {\n    if (import.meta.env.DEV) {\n      console.log(`[TranslationUtils] ${message}`, ...args)\n    }\n  },\n  warn: (message, ...args) => {\n    console.warn(`[TranslationUtils] ${message}`, ...args)\n  },\n  error: (message, ...args) => {\n    console.error(`[TranslationUtils] ${message}`, ...args)\n  }\n}\n\n/**\n * Get nested translation from object using dot notation\n * @param {Object} obj - Translation object\n * @param {string} key - Dot notation key (e.g., 'auth.login.title')\n * @returns {string|null} Translation value or null\n */\nfunction getNestedTranslation(obj, key) {\n  if (!obj || !key) return null\n  \n  const keys = key.split('.')\n  let result = obj\n  \n  for (const k of keys) {\n    if (result && typeof result === 'object' && k in result) {\n      result = result[k]\n    } else {\n      return null\n    }\n  }\n  \n  return typeof result === 'string' ? result : null\n}\n\n/**\n * Fetch dynamic translation for a key using lazy loader\n * @param {string} key - Translation key\n * @param {string} locale - Locale (en, vi)\n * @returns {Promise<string>} Translation or key as fallback\n */\nexport async function fetchDynamicTranslation(key, locale = 'en') {\n  const cacheKey = `${locale}:${key}`\n  \n  // Check cache first\n  if (translationCache.has(cacheKey)) {\n    logger.debug(`fetchDynamicTranslation: Using cached translation for key '${key}'`)\n    return translationCache.get(cacheKey)\n  }\n  \n  logger.debug(`fetchDynamicTranslation: Fetching translation for key '${key}' in locale '${locale}'`)\n  \n  try {\n    // Load translations using lazy loader\n    const translations = await enterpriseI18n.loadingStrategy.load(locale)\n    \n    if (translations) {\n      const translation = getNestedTranslation(translations, key)\n\n      if (translation && translation !== key) {\n        // Cache the result\n        translationCache.set(cacheKey, translation)\n        logger.debug(`fetchDynamicTranslation: Found translation '${translation}' for key '${key}'`)\n        return translation\n      }\n    }\n\n    // Fallback to key itself\n    logger.debug(`fetchDynamicTranslation: No translation found, returning key '${key}'`)\n    return key\n  } catch (error) {\n    logger.error(`fetchDynamicTranslation: Error fetching translation for key '${key}':`, error)\n    return key\n  }\n}\n\n/**\n * Translate elements with data-translate attribute\n * @param {string} locale - Locale to translate to\n */\nexport async function triggerTranslationForElements(locale = 'en') {\n  const elements = document.querySelectorAll('[data-translate]')\n  \n  if (elements.length === 0) {\n    logger.debug('triggerTranslationForElements: No elements with data-translate found')\n    return\n  }\n  \n  logger.debug(`triggerTranslationForElements: Found ${elements.length} elements to translate`)\n  \n  const translationPromises = Array.from(elements).map(async (element) => {\n    const key = element.getAttribute('data-translate')\n    if (!key) return\n    \n    try {\n      const translation = await fetchDynamicTranslation(key, locale)\n      if (translation && translation !== key) {\n        element.textContent = translation\n        logger.debug(`triggerTranslationForElements: Translated '${key}' to '${translation}'`)\n      }\n    } catch (error) {\n      logger.error(`triggerTranslationForElements: Failed to translate '${key}':`, error)\n    }\n  })\n  \n  await Promise.all(translationPromises)\n  logger.debug('triggerTranslationForElements: Completed translation of all elements')\n}\n\n/**\n * Vue composable for dynamic translation\n * @param {string} locale - Locale to translate to\n * @returns {Object} Translation utilities\n */\nexport function useDynamicTranslation(locale = 'en') {\n  const isLoading = ref(false)\n  const error = ref(null)\n  \n  const translate = async (key) => {\n    isLoading.value = true\n    error.value = null\n    \n    try {\n      const result = await fetchDynamicTranslation(key, locale)\n      return result\n    } catch (err) {\n      error.value = err\n      logger.error(`useDynamicTranslation: Error translating '${key}':`, err)\n      return key\n    } finally {\n      isLoading.value = false\n    }\n  }\n  \n  const translateElements = async () => {\n    isLoading.value = true\n    error.value = null\n    \n    try {\n      await triggerTranslationForElements(locale)\n    } catch (err) {\n      error.value = err\n      logger.error('useDynamicTranslation: Error translating elements:', err)\n    } finally {\n      isLoading.value = false\n    }\n  }\n  \n  return {\n    translate,\n    translateElements,\n    isLoading,\n    error\n  }\n}\n\n/**\n * Auto-translate elements when they are added to DOM\n * @param {string} locale - Locale to translate to\n */\nexport function setupAutoTranslation(locale = 'en') {\n  const observer = new MutationObserver(async (mutations) => {\n    const newElements = []\n    \n    mutations.forEach((mutation) => {\n      mutation.addedNodes.forEach((node) => {\n        if (node.nodeType === Node.ELEMENT_NODE) {\n          // Check if the node itself has data-translate\n          if (node.hasAttribute && node.hasAttribute('data-translate')) {\n            newElements.push(node)\n          }\n          \n          // Check for child elements with data-translate\n          const childElements = node.querySelectorAll && node.querySelectorAll('[data-translate]')\n          if (childElements) {\n            newElements.push(...Array.from(childElements))\n          }\n        }\n      })\n    })\n    \n    if (newElements.length > 0) {\n      logger.debug(`setupAutoTranslation: Found ${newElements.length} new elements to translate`)\n      \n      const translationPromises = newElements.map(async (element) => {\n        const key = element.getAttribute('data-translate')\n        if (!key) return\n        \n        try {\n          const translation = await fetchDynamicTranslation(key, locale)\n          if (translation && translation !== key) {\n            element.textContent = translation\n            logger.debug(`setupAutoTranslation: Translated '${key}' to '${translation}'`)\n          }\n        } catch (error) {\n          logger.error(`setupAutoTranslation: Failed to translate '${key}':`, error)\n        }\n      })\n      \n      await Promise.all(translationPromises)\n    }\n  })\n  \n  observer.observe(document.body, {\n    childList: true,\n    subtree: true\n  })\n  \n  logger.debug('setupAutoTranslation: Auto-translation observer started')\n  \n  return () => {\n    observer.disconnect()\n    logger.debug('setupAutoTranslation: Auto-translation observer stopped')\n  }\n}\n\n/**\n * Clear translation cache\n * @param {string} locale - Specific locale to clear, or 'all' to clear all\n */\nexport function clearTranslationCache(locale = 'all') {\n  if (locale === 'all') {\n    translationCache.clear()\n    logger.debug('clearTranslationCache: Cleared all translation cache')\n  } else {\n    const keysToDelete = Array.from(translationCache.keys()).filter(key => key.startsWith(`${locale}:`))\n    keysToDelete.forEach(key => translationCache.delete(key))\n    logger.debug(`clearTranslationCache: Cleared cache for locale '${locale}' (${keysToDelete.length} entries)`)\n  }\n}\n\n/**\n * Initialize translation scanner (legacy function for compatibility)\n * @param {string} locale - Locale to scan for\n */\nexport function initializeTranslationScanner(locale = 'en') {\n  logger.debug(`initializeTranslationScanner: Initializing for locale '${locale}'`)\n  // This function is kept for compatibility but functionality moved to setupAutoTranslation\n  return setupAutoTranslation(locale)\n}\n\n/**\n * Auto translate document (legacy function for compatibility)\n * @param {string} locale - Locale to translate to\n */\nexport async function autoTranslateDocument(locale = 'en') {\n  logger.debug(`autoTranslateDocument: Auto-translating document for locale '${locale}'`)\n  await triggerTranslationForElements(locale)\n}"],"names":["translationCache","logger","message","args","getNestedTranslation","obj","key","keys","result","k","fetchDynamicTranslation","locale","cacheKey","translations","enterpriseI18n","translation","error","triggerTranslationForElements","elements","translationPromises","element"],"mappings":"+CAKA,MAAMA,MAAuB,IAGvBC,EAAS,CACb,MAAO,CAACC,KAAYC,IAAS,CAI7B,EACA,KAAM,CAACD,KAAYC,IAAS,CAC1B,QAAQ,KAAK,sBAAsBD,CAAO,GAAI,GAAGC,CAAI,CACvD,EACA,MAAO,CAACD,KAAYC,IAAS,CAC3B,QAAQ,MAAM,sBAAsBD,CAAO,GAAI,GAAGC,CAAI,CACxD,CACF,EAQA,SAASC,EAAqBC,EAAKC,EAAK,CACtC,GAAI,CAACD,GAAO,CAACC,EAAK,OAAO,KAEzB,MAAMC,EAAOD,EAAI,MAAM,GAAG,EAC1B,IAAIE,EAASH,EAEb,UAAWI,KAAKF,EACd,GAAIC,GAAU,OAAOA,GAAW,UAAYC,KAAKD,EAC/CA,EAASA,EAAOC,CAAC,MAEjB,QAAO,KAIX,OAAO,OAAOD,GAAW,SAAWA,EAAS,IAC/C,CAQA,eAAsBE,EAAwBJ,EAAKK,EAAS,KAAM,CAChE,MAAMC,EAAW,GAAGD,CAAM,IAAIL,CAAG,GAGjC,GAAIN,EAAiB,IAAIY,CAAQ,EAC/B,OAAAX,EAAO,MAAM,8DAA8DK,CAAG,GAAG,EAC1EN,EAAiB,IAAIY,CAAQ,EAGtCX,EAAO,MAAM,0DAA0DK,CAAG,gBAAgBK,CAAM,GAAG,EAEnG,GAAI,CAEF,MAAME,EAAe,MAAMC,EAAe,gBAAgB,KAAKH,CAAM,EAErE,GAAIE,EAAc,CAChB,MAAME,EAAcX,EAAqBS,EAAcP,CAAG,EAE1D,GAAIS,GAAeA,IAAgBT,EAEjC,OAAAN,EAAiB,IAAIY,EAAUG,CAAW,EAC1Cd,EAAO,MAAM,+CAA+Cc,CAAW,cAAcT,CAAG,GAAG,EACpFS,CAEX,CAGA,OAAAd,EAAO,MAAM,iEAAiEK,CAAG,GAAG,EAC7EA,CACT,OAASU,EAAO,CACd,OAAAf,EAAO,MAAM,gEAAgEK,CAAG,KAAMU,CAAK,EACpFV,CACT,CACF,CAMA,eAAsBW,EAA8BN,EAAS,KAAM,CACjE,MAAMO,EAAW,SAAS,iBAAiB,kBAAkB,EAE7D,GAAIA,EAAS,SAAW,EAAG,CACzBjB,EAAO,MAAM,sEAAsE,EACnF,MACF,CAEAA,EAAO,MAAM,wCAAwCiB,EAAS,MAAM,wBAAwB,EAE5F,MAAMC,EAAsB,MAAM,KAAKD,CAAQ,EAAE,IAAI,MAAOE,GAAY,CACtE,MAAMd,EAAMc,EAAQ,aAAa,gBAAgB,EACjD,GAAKd,EAEL,GAAI,CACF,MAAMS,EAAc,MAAML,EAAwBJ,EAAKK,CAAM,EACzDI,GAAeA,IAAgBT,IACjCc,EAAQ,YAAcL,EACtBd,EAAO,MAAM,8CAA8CK,CAAG,SAASS,CAAW,GAAG,EAEzF,OAASC,EAAO,CACdf,EAAO,MAAM,uDAAuDK,CAAG,KAAMU,CAAK,CACpF,CACF,CAAC,EAED,MAAM,QAAQ,IAAIG,CAAmB,EACrClB,EAAO,MAAM,sEAAsE,CACrF"}