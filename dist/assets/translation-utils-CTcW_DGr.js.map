{"version":3,"file":"translation-utils-CTcW_DGr.js","sources":["../../src/utils/translationUtils.js"],"sourcesContent":["// Translation utilities for dynamic content translation\n// NOTE: This file is now deprecated as translations are bundled with sections\n// Keeping minimal utilities for legacy compatibility\nimport { ref, onMounted } from 'vue'\nimport { useI18n } from 'vue-i18n'\n\n// Cache for translations to avoid repeated requests\nconst translationCache = new Map()\n\n// Logger utility\nconst logger = {\n  debug: (message, ...args) => {\n    if (import.meta.env.DEV) {\n      console.log(`[TranslationUtils] ${message}`, ...args)\n    }\n  },\n  warn: (message, ...args) => {\n    console.warn(`[TranslationUtils] ${message}`, ...args)\n  },\n  error: (message, ...args) => {\n    console.error(`[TranslationUtils] ${message}`, ...args)\n  }\n}\n\n/**\n * Get nested translation from object using dot notation\n * @param {Object} obj - Translation object\n * @param {string} key - Dot notation key (e.g., 'auth.login.title')\n * @returns {string|null} Translation value or null\n */\nfunction getNestedTranslation(obj, key) {\n  if (!obj || !key) return null\n  \n  const keys = key.split('.')\n  let result = obj\n  \n  for (const k of keys) {\n    if (result && typeof result === 'object' && k in result) {\n      result = result[k]\n    } else {\n      return null\n    }\n  }\n  \n  return typeof result === 'string' ? result : null\n}\n\n/**\n * Fetch dynamic translation for a key using lazy loader\n * @param {string} key - Translation key\n * @param {string} locale - Locale (en, vi)\n * @returns {Promise<string>} Translation or key as fallback\n */\nexport async function fetchDynamicTranslation(key, locale = 'en') {\n  const cacheKey = `${locale}:${key}`\n  \n  // Check cache first\n  if (translationCache.has(cacheKey)) {\n    logger.debug(`fetchDynamicTranslation: Using cached translation for key '${key}'`)\n    return translationCache.get(cacheKey)\n  }\n  \n  logger.debug(`fetchDynamicTranslation: Fetching translation for key '${key}' in locale '${locale}'`)\n  \n  try {\n    // NOTE: Using Vue i18n instead of enterprise i18n system\n    // This is a fallback utility - sections now bundle their own translations\n    const { t } = useI18n()\n    const translation = t(key, key)\n    \n    if (translation && translation !== key) {\n      // Cache the result\n      translationCache.set(cacheKey, translation)\n      logger.debug(`fetchDynamicTranslation: Found translation '${translation}' for key '${key}'`)\n      return translation\n    }\n\n    // Fallback to key itself\n    logger.debug(`fetchDynamicTranslation: No translation found, returning key '${key}'`)\n    return key\n  } catch (error) {\n    logger.error(`fetchDynamicTranslation: Error fetching translation for key '${key}':`, error)\n    return key\n  }\n}\n\n/**\n * Translate elements with data-translate attribute\n * @param {string} locale - Locale to translate to\n */\nexport async function triggerTranslationForElements(locale = 'en') {\n  const elements = document.querySelectorAll('[data-translate]')\n  \n  if (elements.length === 0) {\n    logger.debug('triggerTranslationForElements: No elements with data-translate found')\n    return\n  }\n  \n  logger.debug(`triggerTranslationForElements: Found ${elements.length} elements to translate`)\n  \n  const translationPromises = Array.from(elements).map(async (element) => {\n    const key = element.getAttribute('data-translate')\n    if (!key) return\n    \n    try {\n      const translation = await fetchDynamicTranslation(key, locale)\n      if (translation && translation !== key) {\n        element.textContent = translation\n        logger.debug(`triggerTranslationForElements: Translated '${key}' to '${translation}'`)\n      }\n    } catch (error) {\n      logger.error(`triggerTranslationForElements: Failed to translate '${key}':`, error)\n    }\n  })\n  \n  await Promise.all(translationPromises)\n  logger.debug('triggerTranslationForElements: Completed translation of all elements')\n}\n\n/**\n * Vue composable for dynamic translation\n * @param {string} locale - Locale to translate to\n * @returns {Object} Translation utilities\n */\nexport function useDynamicTranslation(locale = 'en') {\n  const isLoading = ref(false)\n  const error = ref(null)\n  \n  const translate = async (key) => {\n    isLoading.value = true\n    error.value = null\n    \n    try {\n      const result = await fetchDynamicTranslation(key, locale)\n      return result\n    } catch (err) {\n      error.value = err\n      logger.error(`useDynamicTranslation: Error translating '${key}':`, err)\n      return key\n    } finally {\n      isLoading.value = false\n    }\n  }\n  \n  const translateElements = async () => {\n    isLoading.value = true\n    error.value = null\n    \n    try {\n      await triggerTranslationForElements(locale)\n    } catch (err) {\n      error.value = err\n      logger.error('useDynamicTranslation: Error translating elements:', err)\n    } finally {\n      isLoading.value = false\n    }\n  }\n  \n  return {\n    translate,\n    translateElements,\n    isLoading,\n    error\n  }\n}\n\n/**\n * Auto-translate elements when they are added to DOM\n * @param {string} locale - Locale to translate to\n */\nexport function setupAutoTranslation(locale = 'en') {\n  const observer = new MutationObserver(async (mutations) => {\n    const newElements = []\n    \n    mutations.forEach((mutation) => {\n      mutation.addedNodes.forEach((node) => {\n        if (node.nodeType === Node.ELEMENT_NODE) {\n          // Check if the node itself has data-translate\n          if (node.hasAttribute && node.hasAttribute('data-translate')) {\n            newElements.push(node)\n          }\n          \n          // Check for child elements with data-translate\n          const childElements = node.querySelectorAll && node.querySelectorAll('[data-translate]')\n          if (childElements) {\n            newElements.push(...Array.from(childElements))\n          }\n        }\n      })\n    })\n    \n    if (newElements.length > 0) {\n      logger.debug(`setupAutoTranslation: Found ${newElements.length} new elements to translate`)\n      \n      const translationPromises = newElements.map(async (element) => {\n        const key = element.getAttribute('data-translate')\n        if (!key) return\n        \n        try {\n          const translation = await fetchDynamicTranslation(key, locale)\n          if (translation && translation !== key) {\n            element.textContent = translation\n            logger.debug(`setupAutoTranslation: Translated '${key}' to '${translation}'`)\n          }\n        } catch (error) {\n          logger.error(`setupAutoTranslation: Failed to translate '${key}':`, error)\n        }\n      })\n      \n      await Promise.all(translationPromises)\n    }\n  })\n  \n  observer.observe(document.body, {\n    childList: true,\n    subtree: true\n  })\n  \n  logger.debug('setupAutoTranslation: Auto-translation observer started')\n  \n  return () => {\n    observer.disconnect()\n    logger.debug('setupAutoTranslation: Auto-translation observer stopped')\n  }\n}\n\n/**\n * Clear translation cache\n * @param {string} locale - Specific locale to clear, or 'all' to clear all\n */\nexport function clearTranslationCache(locale = 'all') {\n  if (locale === 'all') {\n    translationCache.clear()\n    logger.debug('clearTranslationCache: Cleared all translation cache')\n  } else {\n    const keysToDelete = Array.from(translationCache.keys()).filter(key => key.startsWith(`${locale}:`))\n    keysToDelete.forEach(key => translationCache.delete(key))\n    logger.debug(`clearTranslationCache: Cleared cache for locale '${locale}' (${keysToDelete.length} entries)`)\n  }\n}\n\n/**\n * Initialize translation scanner (legacy function for compatibility)\n * @param {string} locale - Locale to scan for\n */\nexport function initializeTranslationScanner(locale = 'en') {\n  logger.debug(`initializeTranslationScanner: Initializing for locale '${locale}'`)\n  // This function is kept for compatibility but functionality moved to setupAutoTranslation\n  return setupAutoTranslation(locale)\n}\n\n/**\n * Auto translate document (legacy function for compatibility)\n * @param {string} locale - Locale to translate to\n */\nexport async function autoTranslateDocument(locale = 'en') {\n  logger.debug(`autoTranslateDocument: Auto-translating document for locale '${locale}'`)\n  await triggerTranslationForElements(locale)\n}"],"names":["translationCache","logger","message","args","fetchDynamicTranslation","key","locale","cacheKey","t","useI18n","translation","error","triggerTranslationForElements","elements","translationPromises","element"],"mappings":"+CAOA,MAAMA,MAAuB,IAGvBC,EAAS,CACb,MAAO,CAACC,KAAYC,IAAS,CAI7B,EACA,KAAM,CAACD,KAAYC,IAAS,CAC1B,QAAQ,KAAK,sBAAsBD,CAAO,GAAI,GAAGC,CAAI,CACvD,EACA,MAAO,CAACD,KAAYC,IAAS,CAC3B,QAAQ,MAAM,sBAAsBD,CAAO,GAAI,GAAGC,CAAI,CACxD,CACF,EA+BA,eAAsBC,EAAwBC,EAAKC,EAAS,KAAM,CAChE,MAAMC,EAAW,GAAGD,CAAM,IAAID,CAAG,GAGjC,GAAIL,EAAiB,IAAIO,CAAQ,EAC/B,OAAAN,EAAO,MAAM,8DAA8DI,CAAG,GAAG,EAC1EL,EAAiB,IAAIO,CAAQ,EAGtCN,EAAO,MAAM,0DAA0DI,CAAG,gBAAgBC,CAAM,GAAG,EAEnG,GAAI,CAGF,KAAM,CAAE,EAAAE,CAAA,EAAMC,EAAA,EACRC,EAAcF,EAAEH,EAAKA,CAAG,EAE9B,OAAIK,GAAeA,IAAgBL,GAEjCL,EAAiB,IAAIO,EAAUG,CAAW,EAC1CT,EAAO,MAAM,+CAA+CS,CAAW,cAAcL,CAAG,GAAG,EACpFK,IAITT,EAAO,MAAM,iEAAiEI,CAAG,GAAG,EAC7EA,EACT,OAASM,EAAO,CACd,OAAAV,EAAO,MAAM,gEAAgEI,CAAG,KAAMM,CAAK,EACpFN,CACT,CACF,CAMA,eAAsBO,EAA8BN,EAAS,KAAM,CACjE,MAAMO,EAAW,SAAS,iBAAiB,kBAAkB,EAE7D,GAAIA,EAAS,SAAW,EAAG,CACzBZ,EAAO,MAAM,sEAAsE,EACnF,MACF,CAEAA,EAAO,MAAM,wCAAwCY,EAAS,MAAM,wBAAwB,EAE5F,MAAMC,EAAsB,MAAM,KAAKD,CAAQ,EAAE,IAAI,MAAOE,GAAY,CACtE,MAAMV,EAAMU,EAAQ,aAAa,gBAAgB,EACjD,GAAKV,EAEL,GAAI,CACF,MAAMK,EAAc,MAAMN,EAAwBC,EAAKC,CAAM,EACzDI,GAAeA,IAAgBL,IACjCU,EAAQ,YAAcL,EACtBT,EAAO,MAAM,8CAA8CI,CAAG,SAASK,CAAW,GAAG,EAEzF,OAASC,EAAO,CACdV,EAAO,MAAM,uDAAuDI,CAAG,KAAMM,CAAK,CACpF,CACF,CAAC,EAED,MAAM,QAAQ,IAAIG,CAAmB,EACrCb,EAAO,MAAM,sEAAsE,CACrF"}